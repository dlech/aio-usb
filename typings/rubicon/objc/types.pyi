"""
This type stub file was initially generated by pyright.
"""

import ctypes
from ctypes import Structure, c_double, c_long, c_ushort, c_void_p, sizeof
from typing import Any, Callable, TypeAlias, TypeVar

__all__ = [
    "CFIndex",
    "CFRange",
    "CGFloat",
    "CGGlyph",
    "CGPoint",
    "CGPointMake",
    "CGRect",
    "CGRectMake",
    "CGSize",
    "CGSizeMake",
    "NSEdgeInsets",
    "NSEdgeInsetsMake",
    "NSInteger",
    "NSIntegerMax",
    "NSMakePoint",
    "NSMakeRect",
    "NSMakeSize",
    "NSNotFound",
    "NSPoint",
    "NSRange",
    "NSRect",
    "NSSize",
    "NSTimeInterval",
    "NSUInteger",
    "NSZeroPoint",
    "UIEdgeInsets",
    "UIEdgeInsetsMake",
    "UIEdgeInsetsZero",
    "UniChar",
    "UnknownPointer",
    "__LP64__",
    "__arm64__",
    "__arm__",
    "__i386__",
    "__x86_64__",
    "compound_value_for_sequence",
    "c_ptrdiff_t",
    "ctype_for_encoding",
    "ctype_for_type",
    "ctypes_for_method_encoding",
    "encoding_for_ctype",
    "get_ctype_for_encoding_map",
    "get_ctype_for_type_map",
    "get_encoding_for_ctype_map",
    "register_ctype_for_type",
    "register_encoding",
    "register_preferred_encoding",
    "split_method_encoding",
    "unichar",
    "unregister_ctype",
    "unregister_ctype_all",
    "unregister_ctype_for_type",
    "unregister_encoding",
    "unregister_encoding_all",
    "with_encoding",
    "with_preferred_encoding",
]
__LP64__ = ...
_processor = ...
_any_x86 = ...
__i386__ = ...
__x86_64__ = ...
if _processor:
    _any_arm = ...
else:
    _any_arm = ...
__arm64__ = ...
__arm__ = ...
_ctype_for_type_map = ...

def ctype_for_type(tp):
    """Look up the C type corresponding to the given Python type.

    This conversion is applied to types used in
    :class:`~rubicon.objc.api.objc_method` signatures,
    :class:`~rubicon.objc.api.objc_ivar` types, etc. This function translates
    Python built-in types and :mod:`rubicon.objc` classes to their
    :mod:`ctypes` equivalents. Unregistered types (including types that are
    already ctypes) are returned unchanged.
    """
    ...

def register_ctype_for_type(tp, ctype):  # -> None:
    """Register a conversion from a Python type to a C type."""
    ...

def unregister_ctype_for_type(tp):  # -> None:
    """Unregister a conversion from a Python type to a C type."""
    ...

def get_ctype_for_type_map():  # -> dict[Any, Any]:
    """Get a copy of all currently registered type-to-C type conversions as a
    mapping."""
    ...

_ctype_for_encoding_map = ...
_encoding_for_ctype_map = ...

_T = TypeVar("_T")

def ctype_for_encoding(encoding: bytes) -> Any:
    """Return the C type corresponding to an Objective-C type encoding.

    If a C type has been registered for the encoding, that type is returned.
    Otherwise, if the type encoding represents a compound type (pointer, array,
    structure, or union), the contained types are converted recursively. A new
    C type is then created from the converted ctypes, and is registered for
    the encoding (so that future conversions of the same encoding return the
    same C type).

    For example, the type encoding ``{spam=ic}`` is not registered by default.
    However, the contained types ``i`` and ``c`` are registered, so they are
    converted individually and used to create a new :class:`~ctypes.Structure`
    with two fields of the correct types. The new structure type is then
    registered for the original encoding ``{spam=ic}`` and returned.

    :raises ValueError: if the conversion fails at any point
    """
    ...

def encoding_for_ctype(ctype: Any) -> bytes:
    """Return the Objective-C type encoding for the given ctypes type.

    If a type encoding has been registered for the C type, that encoding is
    returned. Otherwise, if the C type is a pointer type, its pointed-to type
    is encoded and used to construct the pointer type encoding.

    Automatic encoding of other compound types (arrays, structures, and unions)
    is currently not supported. To encode such types, a type encoding must be
    manually provided for them using :func:`register_preferred_encoding` or
    :func:`register_encoding`.

    :raises ValueError: if the conversion fails at any point
    """
    ...

def register_preferred_encoding(encoding: bytes, ctype: Any) -> None:
    """Register a preferred conversion between an Objective-C type encoding and a C
    type.

    "Preferred" means that any existing conversions in each direction are
    overwritten with the new conversion. To register an encoding without
    overwriting existing conversions, use :func:`register_encoding`.
    """
    ...

def with_preferred_encoding(encoding: bytes) -> Callable[[_T], _T]:
    """Register a preferred conversion between an Objective-C type encoding and the
    decorated C type.

    This is equivalent to calling :func:`register_preferred_encoding` on the
    decorated C type.
    """
    ...

def register_encoding(encoding: bytes, ctype: Any) -> None:
    """Register an additional conversion between an Objective-C type encoding and a C
    type.

    "Additional" means that any existing conversions in either direction are
    *not* overwritten with the new conversion. To register an encoding and
    overwrite existing conversions, use :func:`register_preferred_encoding`.
    """
    ...

def with_encoding(encoding: bytes) -> Callable[[_T], _T]:
    """Register an additional conversion between an Objective-C type encoding and the
    decorated C type.

    This is equivalent to calling :func:`register_encoding` on the
    decorated C type.
    """
    ...

def unregister_encoding(encoding: bytes) -> None:
    """Unregister the conversion from an Objective-C type encoding to its corresponding
    C type.

    Note that this does not remove any conversions in the other direction (from
    a C type to this encoding). These conversions may be replaced with
    :func:`register_encoding`, or unregistered with :func:`unregister_ctype`. To
    remove all ctypes for an encoding, use :func:`unregister_encoding_all`.

    If the encoding was not registered previously, nothing happens.
    """
    ...

def unregister_encoding_all(encoding: bytes) -> None:
    """Unregister all conversions between an Objective-C type encoding and all
    corresponding ctypes.

    All conversions from any C type to this encoding are removed recursively
    using :func:`unregister_ctype_all`.

    If the encoding was not registered previously, nothing happens.
    """
    ...

def unregister_ctype(ctype: Any) -> None:
    """Unregister the conversion from a C type to its corresponding Objective-C type
    encoding.

    Note that this does not remove any conversions in the other direction (from
    an encoding to this C type). These conversions may be replaced with
    :func:`register_encoding`, or unregistered with :func:`unregister_encoding`.
    To remove all encodings for a C type, use :func:`unregister_ctype_all`.

    If the C type was not registered previously, nothing happens.
    """
    ...

def unregister_ctype_all(ctype: Any) -> None:
    """Unregister all conversions between a C type and all corresponding Objective-C
    type encodings.

    All conversions from any type encoding to this C type are removed
    recursively using :func:`unregister_encoding_all`.

    If the C type was not registered previously, nothing happens.
    """
    ...

def get_ctype_for_encoding_map() -> dict[bytes, Any]:
    """Get a copy of all currently registered encoding-to-C type conversions as a
    map."""
    ...

def get_encoding_for_ctype_map() -> dict[Any, bytes]:
    """Get a copy of all currently registered C type-to-encoding conversions as a
    map."""
    ...

def split_method_encoding(encoding: bytes) -> list[bytes]:
    """Split a method signature encoding into a sequence of type encodings.

    The first type encoding represents the return type, all remaining type encodings
    represent the argument types.

    If there are any numbers after a type encoding, they are ignored. On PowerPC, these
    numbers indicated each argument/return value's offset on the stack. These numbers
    are meaningless on modern architectures.
    """
    ...

def ctypes_for_method_encoding(encoding: bytes) -> list[Any]:
    """Convert a method signature encoding into a sequence of ctypes.

    This is equivalent to first splitting the method signature encoding using
    :func:`split_method_encoding`, and then converting each individual type
    encoding using :func:`ctype_for_encoding`.
    """
    ...

def compound_value_for_sequence(seq, tp):  # -> Structure | Array[Any]:
    """Create a C structure or array of type ``tp``, initialized with values from
    ``seq``.

    If ``tp`` is a :class:`~ctypes.Structure` type, the newly created
    structure's fields are initialized in declaration order with the values from
    ``seq``. ``seq`` must have as many elements as the structure has fields.

    If ``tp`` is a :class:`~ctypes.Array` type, the newly created array is
    initialized with the values from ``seq``. ``seq`` must have as many elements
    as the array type.

    In both cases, if a structure field type or the array element type is itself
    a structure or array type, the corresponding value from ``seq`` is
    recursively converted as well.
    """
    ...

NSInteger: TypeAlias = ctypes.c_long
NSUInteger: TypeAlias = ctypes.c_ulong

if __LP64__:
    c_ptrdiff_t = ...
    CGFloat = ...
    _CGPointEncoding = ...
    _CGSizeEncoding = ...
    _CGRectEncoding = ...
    _NSRangeEncoding = ...
    _UIEdgeInsetsEncoding = ...
    _NSEdgeInsetsEncoding = ...
    _PyObjectEncoding = ...
else:
    c_ptrdiff_t = ...
    CGFloat = ...
    _NSPointEncoding = ...
    _CGPointEncoding = ...
    _NSSizeEncoding = ...
    _CGSizeEncoding = ...
    _NSRectEncoding = ...
    _CGRectEncoding = ...
    _NSRangeEncoding = ...
    _UIEdgeInsetsEncoding = ...
    _NSEdgeInsetsEncoding = ...
    _PyObjectEncoding = ...

@with_preferred_encoding(b"^?")
@with_encoding(b"^{?}")
@with_encoding(b"^(?)")
class UnknownPointer(c_void_p):
    """Placeholder for the "unknown pointer" types ``^?``, ``^{?}`` and ``^(?)``.

    Not to be confused with a ``^v`` void pointer.

    Usually a ``^?`` is a function pointer, but because the encoding doesn't
    contain the function signature, you need to manually create a CFUNCTYPE with
    the proper types, and cast this pointer to it.

    ``^{?}`` and ``^(?)`` are pointers to a structure or union (respectively)
    with unknown name and fields. Such a type also cannot be used meaningfully
    without casting it to the correct pointer type first.
    """

    ...

@with_preferred_encoding(_NSPointEncoding)
class NSPoint(Structure):
    _fields_ = ...
    def __repr__(self):  # -> str:
        ...
    def __str__(self) -> str: ...

if _CGPointEncoding == _NSPointEncoding:
    CGPoint = ...
else:
    @with_preferred_encoding(_CGPointEncoding)
    class CGPoint(Structure):
        _fields_ = ...
        def __repr__(self):  # -> str:
            ...
        def __str__(self) -> str: ...

@with_preferred_encoding(_NSSizeEncoding)
class NSSize(Structure):
    _fields_ = ...
    def __repr__(self):  # -> str:
        ...
    def __str__(self) -> str: ...

if _CGSizeEncoding == _NSSizeEncoding:
    CGSize = ...
else:
    @with_preferred_encoding(_CGSizeEncoding)
    class CGSize(Structure):
        _fields_ = ...
        def __repr__(self):  # -> str:
            ...
        def __str__(self) -> str: ...

@with_preferred_encoding(_NSRectEncoding)
class NSRect(Structure):
    _fields_ = ...
    def __repr__(self):  # -> str:
        ...
    def __str__(self) -> str: ...

if _CGRectEncoding == _NSRectEncoding:
    CGRect = ...
else:
    @with_preferred_encoding(_CGRectEncoding)
    class CGRect(Structure):
        _fields_ = ...

    def __repr__(self):  # -> str:
        ...
    def __str__(self) -> str: ...

def NSMakeSize(w, h):  # -> NSSize:
    ...
def CGSizeMake(w, h):  # -> CGSize:
    ...
def NSMakeRect(x, y, w, h):  # -> NSRect:
    ...
def CGRectMake(x, y, w, h):  # -> CGRect:
    ...
def NSMakePoint(x, y):  # -> NSPoint:
    ...
def CGPointMake(x, y):  # -> CGPoint:
    ...
@with_preferred_encoding(_UIEdgeInsetsEncoding)
class UIEdgeInsets(Structure):
    _fields_ = ...
    def __repr__(self):  # -> str:
        ...
    def __str__(self) -> str: ...

def UIEdgeInsetsMake(top, left, bottom, right):  # -> UIEdgeInsets:
    ...

UIEdgeInsetsZero = ...

@with_preferred_encoding(_NSEdgeInsetsEncoding)
class NSEdgeInsets(Structure):
    _fields_ = ...
    def __repr__(self):  # -> str:
        ...
    def __str__(self) -> str: ...

def NSEdgeInsetsMake(top, left, bottom, right):  # -> NSEdgeInsets:
    ...

NSTimeInterval = c_double
CFIndex = c_long
UniChar = c_ushort
unichar = c_ushort
CGGlyph = c_ushort

class CFRange(Structure):
    _fields_ = ...
    def __repr__(self):  # -> str:
        ...
    def __str__(self) -> str: ...

@with_preferred_encoding(_NSRangeEncoding)
class NSRange(Structure):
    _fields_ = ...
    def __repr__(self):  # -> str:
        ...
    def __str__(self) -> str: ...

NSZeroPoint = ...
if sizeof(c_void_p) == 4:
    NSIntegerMax = ...
else:
    NSIntegerMax = ...
NSNotFound = ...

# Dynamically generated types

class __CFDictionary(ctypes._CData): ...

LP___CFDictionary = ctypes.POINTER(__CFDictionary)
